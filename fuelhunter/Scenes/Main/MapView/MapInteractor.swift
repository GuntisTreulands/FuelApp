//
//  MapInteractor.swift
//  fuelhunter
//
//  Created by Guntis on 12/08/2019.
//  Copyright (c) 2019 . All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import MapKit
import CoreData
import FirebaseCrashlytics

protocol MapBusinessLogic {
  	func getData(request: Map.MapData.Request)
  	func userPressedOnMapPin(request: Map.MapWasPressed.Request)
  	func openHomePageForCurrentCompany()
  	func openNavigationForAppType(request: Map.MapNavigationRequested.Request)
}

protocol MapDataStore {
  	var selectedFuelType: FuelType { get set }
  	var selectedCompany: CompanyEntity? { get set }
  	var selectedPrice: PriceEntity? { get set }
	var yLocation: CGFloat { get set }
}

class MapInteractor: NSObject, MapBusinessLogic, MapDataStore, NSFetchedResultsControllerDelegate {
	var presenter: MapPresentationLogic?
	var fetchedResultsController: NSFetchedResultsController<PriceEntity>!
  	var worker = MapWorker()
  	var selectedFuelType: FuelType = .type95
  	var selectedCompany: CompanyEntity?
  	var selectedPrice: PriceEntity?
	var yLocation: CGFloat = 0

	var convertedDataArray: [Map.MapData.ViewModel.DisplayedMapPoint] = []
	var mapPoints: [MapPoint] = []
	var selectedPriceObject: PriceEntity?
	var selectedDisplayedPoint: Map.MapData.ViewModel.DisplayedMapPoint?
	var allValidCompanies: [CompanyEntity]?
	var allValidPrices: [PriceEntity]?
	var allValidFilteredPrices: [PriceEntity]?
	var allAddressesWithoutDistances: [AddressEntity]?

	var addressDistanceCalculatingInProgress = false

  	// MARK: MapBusinessLogic

  	func getData(request: Map.MapData.Request) {

//		var shouldUseCheapestCompany = false
//		let cheapestCompanyFetchRequest: NSFetchRequest<CompanyEntity> = CompanyEntity.fetchRequest()
//		cheapestCompanyFetchRequest.predicate = NSPredicate(format: "isCheapestToggle == %i", true)
//		if let companyObjectArray = try? DataBaseManager.shared.mainManagedObjectContext().fetch(cheapestCompanyFetchRequest) {
//			if !companyObjectArray.isEmpty {
//				shouldUseCheapestCompany = companyObjectArray.first!.isEnabled
//			}
//		}

		if request.forcedReload == true {
			fetchedResultsController = nil
		}
		
		if fetchedResultsController == nil {
			let context = DataBaseManager.shared.mainManagedObjectContext()
			let fetchRequest: NSFetchRequest<PriceEntity> = PriceEntity.fetchRequest()

//			if shouldUseCheapestCompany == true {
//				fetchRequest.predicate = NSPredicate(format: "(isCheapest == %i || (companyMetaData.company.isEnabled = %i && companyMetaData.company.isHidden = %i)) && fuelType == %@", true, true, false, selectedFuelType.rawValue)
//			} else
//			{
				fetchRequest.predicate = NSPredicate(format: "companyMetaData.company.isEnabled = %i && companyMetaData.company.isHidden = %i && (fuelType == %@ || notEntered == %i) ", true, false, selectedFuelType.rawValue, true)
//			}

			let sortPrice = NSSortDescriptor(key: "price", ascending: true)
			fetchRequest.sortDescriptors = [sortPrice]
			fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil)

			fetchedResultsController.delegate = self
		}

		do {
			try fetchedResultsController.performFetch()

			allValidPrices = fetchedResultsController.fetchedObjects

			allValidFilteredPrices = allValidPrices?.filter( {$0.notEntered == false})
		} catch let error {
			// Something went wrong
			Crashlytics.crashlytics().record(error: error)
			print("Something went wrong. \(error)")
		}


		//--- Get usable companies
		let context = DataBaseManager.shared.mainManagedObjectContext()
		let fetchRequest: NSFetchRequest<CompanyEntity> = CompanyEntity.fetchRequest()
//		fetchRequest.predicate = NSPredicate(format: "isCheapestToggle == \(false)")

		if let onlyValidEnabledCompanies = try? context.fetch(fetchRequest) {
			allValidCompanies = onlyValidEnabledCompanies
		}
		//===

		/*
			If we have user location enabled,

			We need to gather locations every time we fetch locations, but we should not interfere with forwarding process.


			1.) Get all addresses that needs distance measurement
			2.) Store this array
			3.) One by one, need to forward to AddressWorker, to calculate address. When finished,
				completion block returns back here, and if "here" exists, we forward next one, until all done.
			4.) AddressWorker, when finishes, updates address, and, somewhow we need pins to update (but maybe it will happen automatically)
		*/
		if AppSettingsWorker.shared.getGPSIsEnabled() == true {
			allAddressesWithoutDistances = worker.getAllAddressesThatNeedsDistanceMeasurement(from: allValidPrices!)

			startCalculatingAddress()
		}

		convertedDataArray = worker.createUsableDataArray(fromPricesArray: allValidPrices!, companiesArray: allValidCompanies ?? [])
		mapPoints = createMapPoints(from: convertedDataArray)

		selectedPriceObject = selectedPrice
		
		let selectedMapPoint = mapPoints.first(where: {$0.priceId == selectedPrice?.id}) ?? mapPoints.first
//		selectedPriceObject = allValidPrices?.first(where: {$0.companyMetaData?.company == selectedCompany}) ?? allValidPrices?.first

		selectedDisplayedPoint = convertedDataArray.first(where: {$0.id == selectedPrice?.id}) ?? convertedDataArray.first

		var cellBackgroundType = CellBackgroundType.middle

		if allValidPrices?.count == 1 {
			cellBackgroundType = .single
		} else {
			if allValidFilteredPrices?.first == selectedPriceObject {
				cellBackgroundType = .top
			} else if allValidFilteredPrices?.last == selectedPriceObject {
				cellBackgroundType = .bottom
			}
		}
		
		let response = Map.MapData.Response(displayedPoints: convertedDataArray, mapPoints: mapPoints, selectedDisplayedPoint: selectedDisplayedPoint, selectedMapPoint: selectedMapPoint, cellType: cellBackgroundType)

    	presenter?.presentData(response: response)
  	}

  	func userPressedOnMapPin(request: Map.MapWasPressed.Request) {
		selectedCompany = request.mapPoint.company
//		selectedPriceObject = allValidPrices?.first(where: {$0.companyMetaData?.company == selectedCompany}) ?? allValidPrices?.first

		selectedPriceObject = allValidPrices?.first(where: {$0.id == request.mapPoint.priceId}) ?? allValidPrices?.first

		selectedDisplayedPoint = convertedDataArray.first(where: {$0.addressName == request.mapPoint.address}) ?? convertedDataArray.first

		let mapObjects = createMapPoints(from: [selectedDisplayedPoint!])

		var cellBackgroundType = CellBackgroundType.middle

		if allValidPrices?.count == 1 {
			cellBackgroundType = .single
		} else {

			if allValidFilteredPrices?.first == selectedPriceObject {
				cellBackgroundType = .top
			} else if allValidFilteredPrices?.last == selectedPriceObject {
				cellBackgroundType = .bottom
			}
		}

		let response = Map.MapWasPressed.Response(selectedDisplayedPoint: selectedDisplayedPoint, selectedMapPoint: mapObjects.first!, selectedPrice: selectedPriceObject!, cellType: cellBackgroundType)

		presenter?.updateToRevealMapPoint(response: response)
  	}

	func openHomePageForCurrentCompany() {
		if let companyHomePage = selectedCompany?.homePage {
			UIApplication.shared.open(URL(string: companyHomePage)!, options: [:], completionHandler: nil)
		}
	}

	func openNavigationForAppType(request: Map.MapNavigationRequested.Request) {
		var url: String?
		if let selectedDisplayedPoint = selectedDisplayedPoint {
			switch request.mapAppType {
				case .Waze:
					url = "waze://?ll=\(selectedDisplayedPoint.latitude),\(selectedDisplayedPoint.longitude)&navigate=yes"
				case .GoogleMaps:
					url = "comgooglemaps://?daddr=\(selectedDisplayedPoint.latitude),\(selectedDisplayedPoint.longitude)&directionsmode=driving"
				case .iOSMaps:
					url = "http://maps.apple.com?daddr=\(selectedDisplayedPoint.latitude),\(selectedDisplayedPoint.longitude)&directionsmode=driving"
			}
		}

		if let url = url { UIApplication.shared.open(URL(string: url)!) }
	}

  	// MARK: Functions

  	func createMapPoints(from data: [Map.MapData.ViewModel.DisplayedMapPoint]) -> [MapPoint] {
  		let mapPoints = data.map { MapPoint(priceId: $0.id, title: $0.company.name ?? " ", company: $0.company, address: $0.addressName, coordinate:
  			CLLocationCoordinate2D(latitude: $0.latitude, longitude: $0.longitude), priceText: $0.price, distanceInMeters: $0.distanceInMeters, priceIsCheapest: $0.isPriceCheapest) }

  		return mapPoints
  	}

	func updatMapPinFor(address: AddressEntity) {
		let allConvertedDataArray = worker.createUsableDataArray(fromPricesArray: allValidPrices!, companiesArray: allValidCompanies ?? [])
		let allMapPoints = createMapPoints(from: allConvertedDataArray)

		let dataObject = convertedDataArray.first(where: {$0.addressName == address.address})
		if var dataObject = dataObject {
			dataObject.distanceEstimatedTime = address.estimatedTimeInMinutes
			dataObject.distanceInMeters = Double(address.distanceInMeters)
			let mapObjects = createMapPoints(from: [dataObject])
			if mapObjects.isEmpty == false {
				//--- Now update convertedDataArray and MapPoints, because they might be used when user switches location (won't refetch data)
				let index = convertedDataArray.firstIndex(where: {$0.addressName == address.address})
				convertedDataArray.remove(at: index!)
				convertedDataArray.insert(dataObject, at: index!)
				mapPoints = createMapPoints(from: convertedDataArray)
				//===

				let response = Map.MapPinRefresh.Response(mapPoint: mapObjects.first!, mapPoints: allMapPoints)
				presenter?.updateData(response: response)
			}
		}
	}

	func startCalculatingAddress() {
		print("startCalculatingAddress |")
		if addressDistanceCalculatingInProgress == true {
			print("startCalculatingAddress | already in progress. Stopping.")
			return
		}

		if let tmpAllAddresses = allAddressesWithoutDistances, tmpAllAddresses.isEmpty == false {
			let addressToCalculate = tmpAllAddresses.first(where: {$0.distanceInMeters == -1 && $0.notEntered == false})
			if let addressToCalculate = addressToCalculate {
				addressDistanceCalculatingInProgress = true
				AddressesWorker.calculateDistance(for: addressToCalculate) { [weak self] updatedAddress in

					print("startCalculatingAddress | AddressesWorker.calculateDistance returned! ")
					self?.addressDistanceCalculatingInProgress = false
					print("startCalculatingAddress | Stopped.")
					
					if updatedAddress.distanceInMeters > -1 {
						print("startCalculatingAddress | Remove previous versions and starting again.")
						self?.allAddressesWithoutDistances?.removeAll(where: {$0.address == addressToCalculate.address})
						self?.updatMapPinFor(address: updatedAddress)
						self?.startCalculatingAddress()
					}
				}
			} else {
				print("startCalculatingAddress | Did not find any address to use.")
			}
		}
	}

	// MARK: NSFetchedResultsControllerDelegate

  	func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
		getData(request: Map.MapData.Request(forcedReload: false))
	}
}
