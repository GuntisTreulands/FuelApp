//
//  FuelListInteractor.swift
//  fuelhunter
//
//  Created by Guntis on 03/06/2019.
//  Copyright (c) 2019 . All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData
import FirebaseCrashlytics

protocol FuelListBusinessLogic {
	func updateCityView(request: FuelList.UpdateCityView.Request)
	func fetchPrices(request: FuelList.FetchPrices.Request)
	func prepareToRevealMapWithRequest(request: FuelList.RevealMap.Request)
	func checkIfThereAreCompanyChangesToPresent() -> Bool
}

protocol FuelListDataStore {
}

class FuelListInteractor: NSObject, FuelListBusinessLogic, FuelListDataStore, NSFetchedResultsControllerDelegate {
	
	var presenter: FuelListPresentationLogic?
	var fetchedResultsController: NSFetchedResultsController<PriceEntity>!
	var insertItems = [IndexPath]()
	var deleteItems = [IndexPath]()
	var updateItems = [IndexPath]()
	var insertSections = [Int]()
	var deleteSections = [Int]()
	var updateSections = [Int]()

	// MARK: FuelListBusinessLogic

	func updateCityView(request: FuelList.UpdateCityView.Request) {
		let currentCityName = AppSettingsWorker.shared.getStoredLastGPSDetectedCityName()
		let gpsIconShouldBeEnabled = AppSettingsWorker.shared.getGPSIsEnabled()

		let response = FuelList.UpdateCityView.Response(currentCityName: currentCityName, currentCityGPSIconEnabled: gpsIconShouldBeEnabled)
    	presenter?.updateCityView(response: response)
	}

	func fetchPrices(request: FuelList.FetchPrices.Request) {
		let fuelTypesStatus = AppSettingsWorker.shared.getFuelTypeToggleStatus()

		var filteredArray = [String]()
		if fuelTypesStatus.typeDD { filteredArray.append(FuelType.typeDD.rawValue) }
		if fuelTypesStatus.type95 { filteredArray.append(FuelType.type95.rawValue) }
		if fuelTypesStatus.type98 { filteredArray.append(FuelType.type98.rawValue) }
		if fuelTypesStatus.typeGas { filteredArray.append(FuelType.typeGas.rawValue) }

//		var shouldUseCheapestCompany = false
//		let fetchRequest: NSFetchRequest<CompanyEntity> = CompanyEntity.fetchRequest()
//		fetchRequest.predicate = NSPredicate(format: "isCheapestToggle == %i", true)
//		if let companyObjectArray = try? DataBaseManager.shared.mainManagedObjectContext().fetch(fetchRequest) {
//			if !companyObjectArray.isEmpty {
//				shouldUseCheapestCompany = companyObjectArray.first!.isEnabled
//			}
//		}

//		if PricesDownloader.isAllowedToDownload() {
//
//			print("AAA")
//			print("BBB")
//		}

		if request.forcedReload == true {
			fetchedResultsController = nil
		}

		if fetchedResultsController == nil {
			let context = DataBaseManager.shared.mainManagedObjectContext()
			let fetchRequest: NSFetchRequest<PriceEntity> = PriceEntity.fetchRequest()

//			if shouldUseCheapestCompany == true {
//				fetchRequest.predicate = NSPredicate(format: "((isCheapest == %i && companyMetaData != nil) || (companyMetaData.company.isEnabled = %i && companyMetaData.company.isHidden = %i)) && fuelType IN %@", true, true, false, filteredArray)
//			} else
//			{
				fetchRequest.predicate = NSPredicate(format: "companyMetaData.company.isEnabled = %i && companyMetaData.company.isHidden = %i && fuelType IN %@ && notEntered == %i", true, false, filteredArray, false)
//			}

			let sortOrder = NSSortDescriptor(key: "fuelSortId", ascending: true)
			let sortPrice = NSSortDescriptor(key: "price", ascending: true)
			fetchRequest.sortDescriptors = [sortOrder, sortPrice]
			fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: "fuelSortId", cacheName: nil)

			fetchedResultsController.delegate = self
		}

		var fetchedPrices: [PriceEntity]?

		do {
			try fetchedResultsController.performFetch()

			print("PricesDownloader.shouldInitiateDownloadWhenPossible() === \(PricesDownloader.shouldInitiateDownloadWhenPossible())")

			if PricesDownloader.shouldInitiateDownloadWhenPossible() == false {
				fetchedPrices = fetchedResultsController.fetchedObjects
			} else {
				insertItems.removeAll()
				updateItems.removeAll()
				deleteItems.removeAll()
				insertSections.removeAll()
				updateSections.removeAll()
				deleteSections.removeAll()
			}
		} catch let error {
			// Something went wrong
			Crashlytics.crashlytics().record(error: error)
			print("Something went wrong. \(error)")
		}

		if let firstPrice = fetchedPrices?.first {
			let allAddresses = firstPrice.addresses?.allObjects as! [AddressEntity]
			if allAddresses.isEmpty {
				print("For some reason (probably addresses updated.. first price does not have addresses. Reset downloader")
				PricesDownloader.removeAllPricesAndCallDownloader()
			}
		}


		/*
			1.) We fetch in sections, Thus it is well sorted, and controller will return us indexpaths of changes
			2.) But we forward simple unsectioned data, but that is allright, we need to map each item to model objects anyway.

		*/

		let response = FuelList.FetchPrices.Response(fetchedPrices: fetchedPrices ?? [], insertItems: insertItems, deleteItems: deleteItems, updateItems: updateItems, insertSections: insertSections, deleteSections: deleteSections, updateSections: updateSections)
    	presenter?.presentData(response: response)
	}

	func prepareToRevealMapWithRequest(request: FuelList.RevealMap.Request) {
		let response = FuelList.RevealMap.Response(selectedCompany: request.selectedCompany, selectedPrice: request.selectedPrice, selectedFuelType: request.selectedFuelType, selectedCellYPosition: request.selectedCellYPosition)

		self.presenter?.revealMapView(response: response)
	}

	func checkIfThereAreCompanyChangesToPresent() -> Bool {
		let fetchRequest: NSFetchRequest<CompanyEntity> = CompanyEntity.fetchRequest()
		fetchRequest.predicate = NSPredicate(format: "shouldPopUpToUser == %i", true)
		if let companyObjectArray = try? DataBaseManager.shared.mainManagedObjectContext().fetch(fetchRequest) {

			if !companyObjectArray.isEmpty {
				return true
			}
		}

		return false
	}

	// MARK: NSFetchedResultsControllerDelegate

	func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
		insertItems.removeAll()
		updateItems.removeAll()
		deleteItems.removeAll()
		insertSections.removeAll()
		updateSections.removeAll()
		deleteSections.removeAll()
	}

	func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
		switch type {
			case .insert:
				if let newIndexPath = newIndexPath {
					insertItems.append(newIndexPath)
				}
			case .delete:
				if let indexPath = indexPath {
					deleteItems.append(indexPath)
				}
			case .update:
				if let indexPath = indexPath {
					updateItems.append(indexPath)
				}
			case .move:
				if let indexPath = indexPath, let newIndexPath = newIndexPath {
					deleteItems.append(indexPath)
					insertItems.append(newIndexPath)
				}
			default:
				break
		}
	}

	func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) {

		switch type {
			case .insert:
				insertSections.append(sectionIndex)
			case .delete:
				deleteSections.append(sectionIndex)
			case .update:
				updateSections.append(sectionIndex)
			case .move:
				deleteSections.append(sectionIndex)
				insertSections.append(sectionIndex)
			default:
				break
		}
	}
	
  	func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
		fetchPrices(request: FuelList.FetchPrices.Request(forcedReload: false))
		insertItems.removeAll()
		updateItems.removeAll()
		deleteItems.removeAll()
		insertSections.removeAll()
		updateSections.removeAll()
		deleteSections.removeAll()
	}
}
